from typing import Tuple, List
import logging

import h5py
import numpy as np


def load_h5_signal(signal_file: str) -> Tuple[np.ndarray, np.ndarray]:
    """Read JEMRIS signal file (simulation output) and return tuple of arrays,
    one for magnetization and one for the time points.

    :param signal_file: JEMRIS output
    :return: Tuple: 1) sorted time points, 2) magnetization time series of shape
    (no_timepoints, 3) with separated vector components)
    """
    with h5py.File(signal_file, 'r') as f:
        channels = f['signal']['channels']
        times = np.array(f['signal']['times'])

        sorting_time_indices = times.argsort(axis=0)
        magnetization_sorted_by_time = np.array(
            [channels[i][sorting_time_indices] for i in channels]
        )

    return times[sorting_time_indices], magnetization_sorted_by_time


def complexify_signals(signals: np.ndarray) -> np.ndarray:
    """Use first and second magnetization vector component for building complex
    signal (Mx + iMy).

    :param signals:
    :return:
    """
    return np.array([
        # calculate Mx + iMy for each time point
        # return array of shape (channels, no_time_points)
        [complex(a, b) for a, b in zip(channel[:, 1], channel[:, 0])] for channel in signals
    ])


def flash_order_kspace(signals: np.ndarray, dimensions: Tuple[int, int, int],
                       echos: int) -> np.ndarray:
    """Sort MRI signal into kspace, assuming the signal was generated by a
    FLASH sequence with full kspace sampling. Each channel will be treated separately.

    :param signals:
    :param dimensions:
    :param echos:
    :return: ndarray of shape (z, echos, y, x, channels) representing the kspace data
    """
    x, y, z = dimensions
    channels = signals.shape[0]
    logging.debug(f"Signal shape: {signals.shape}")
    mxy = complexify_signals(signals)
    logging.debug(f"Shape of transverse relaxation (Mx+iMy): {mxy.shape}")
    try:
        mxy = np.reshape(mxy.transpose(), (z, echos, y, x, channels), order='F')
    except ValueError as err:
        print('Please make sure that your signal can be reshaped into the '
              'specified dimensions using this number of echos.')
        raise err
    return mxy


def basic_2d_recon(signals_h5: str, dims: Tuple[int, int, int] = (434, 496, 352),
                   echos: int = 6, x_slice=0, channel=0) -> List[np.ndarray]:
    _, m = load_h5_signal(signals_h5)
    kspaces = [flash_order_kspace(m, dimensions=dims, echos=echos)[:, echo, :, x_slice, channel] for echo in range(6)]
    kspaces = [np.flip(kspace, axis=0) if i % 2 == 1 else kspace for i, kspace in enumerate(kspaces)]
    return [np.absolute(np.fft.ifftshift(np.fft.ifft2(kspace))) for kspace in kspaces]
